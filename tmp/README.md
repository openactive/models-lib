# models-ts

Model validation and TypeScript types for OpenActive's data model

This library works for both JavaScript and TypeScript developers, making it easier to conform to the OpenActive specifications.

Example:

```ts
import * as Joi from 'joi';
import { OaValidationResult } from '@openactive/models-ts';
// OpenActive types live at /lib/oa
import { Event, RequiredStatusType } from '@openactive/models-ts/lib/oa';
// Schema.org types live at /lib/schema
import { DayOfWeek, ImageObject } from '@openactive/models-ts/lib/schema';

// TypeScript type lives at `.Type`
const myRequiredStatusType: RequiredStatusType.Type = 'https://openactive.io/Required';
const myNotRequiredStatusType: RequiredStatusType.Type = 'somethingelse.com'; // this will raise a TS error

// Validator lives at `.validate(..)`
const maybeRequiredStatusType = RequiredStatusType.validate('https://openactive.io/Optional');
if (maybeRequiredStatusType instanceof OaValidationResult) {
  // From this point on, `maybeRequiredStatusType` will have type `OaValidationError`
  const error = maybeRequiredStatusType;
  // Do something with the error. Maybe ignore it? Or log it? Or throw? Up to you.
} else {
  // From this point on, `maybeRequiredStatusType` will have type `RequiredStatusType.Type`
  const requiredStatusType = maybeRequiredStatusType;
}

// JOI Schema lives at `.JoiSchema`
const compositeJoiSchema = Joi.object({
  somethingElse: Joi.string(),
  requiredStatusType: RequiredStatusType.JoiSchema,
});

// A few more type examples
const event: Event.Type = {
  '@type': 'Event',
  name: 'myEvent',
};
const dayOfWeek: DayOfWeek.Type = 'https://schema.org/Sunday';
const imageObject: ImageObject.Type = {
  '@type': 'ImageObject',
  url: 'https://example.com/image.jpg',
};
```

## Using Types in a JavaScript Project

It is recommended to use TypeScript, which allows for more seamless use of the types in this library. However, it is
absolutely possible to use them in JavaScript by using JSDoc.

Here's how:

1. Ensure you're using a TypeScript-aware editor like VSCode.
2. Install TypeScript in your project

    ```sh
    npm install --save-dev typescript
    ```
3. Create a `tsconfig.json` file at the root of your project with the following contents:

    ```json
    {
      "compilerOptions": {
        "noEmit": true,
        "allowJs": true,
        "checkJs": true,
      },
      "include": [
        "src/**/*.js" // replace with the path to all of your JS files.
      ]
    }
    ```

    The top 3 options mean that 1). TypeScript will not produce any output - it will just check files 2). It will
    check .js files.

    More info on options you can put in tsconfig.json [here](https://www.typescriptlang.org/tsconfig).

    It is highly recommended that you use `"strict": true` in your `compilerOptions`, which improves TypeScript's
    ability to catch issues before they happen live. However, if you do this, you will have to make sure to annotate
    every function in your project.
4. Annotate your functions with type signatures using JSDoc.

    e.g.

    ```js
    /**
     * @param {number} x
     * @param {number} y
     * @returns {number}
     */
    function add(x, y) { return x + y; }

    /**
     * @template T
     * @param {T} val
     * @returns {{ val: T }}
     */
    function wrap(val) { return { val }; }
    ```

    (Note: you will often not need to annotate return values, which TypeScript can infer. You can see what TypeScript
    has inferred by hovering over the function in VSCode).
5. Run `npx tsc` to check your files. Ensure this happens frequently by including it in your CI scripts.

## Contributing

- `lib/*` files are generated by TypeScript
- A pre-commit hook re-builds the above files